"""
API server for the application.
This server handles incoming requests and routes them to the appropriate blueprints.
Also provides a health check endpoint.
"""

# Library imports
from typing import Union, List, Dict, Any, Tuple, Optional
from os import listdir as os_listdir
from os.path import join as os_path_join
from os.path import dirname as os_path_dirname
from os.path import abspath as os_path_abspath
from importlib import import_module
from flask import Flask, jsonify, request, Blueprint
from flask_jwt_extended import JWTManager
from flask_marshmallow import Marshmallow
from flasgger import Swagger
import re
import hashlib
import hmac
import unicodedata
import sys
from sqlalchemy.exc import OperationalError

# Local imports
from api_blueprints.blueprints_utils import log, is_rate_limited
from models import db
from config import (
    API_SERVER_HOST,
    API_SERVER_PORT,
    API_SERVER_DEBUG_MODE,
    STATUS_CODES,
    API_VERSION,
    URL_PREFIX,
    JWT_SECRET_KEY,
    JWT_ALGORITHM,
    JWT_QUERY_STRING_NAME,
    JWT_JSON_KEY,
    JWT_REFRESH_JSON_KEY,
    JWT_TOKEN_LOCATION,
    JWT_REFRESH_TOKEN_EXPIRES,
    API_SERVER_RATE_LIMIT,
    API_SERVER_SSL,
    API_SERVER_SSL_CERT,
    API_SERVER_SSL_KEY,
    API_SERVER_MAX_JSON_SIZE,
    SQL_SCAN_MAX_LEN,
    SQL_PATTERN,
    SQL_SCAN_MAX_RECURSION_DEPTH,
    SQLALCHEMY_DATABASE_URI,
    SQLALCHEMY_TRACK_MODIFICATIONS,
    SWAGGER_CONFIG,
    INVALID_JWT_MESSAGES,
)

# Create a Flask app
main_api = Flask(__name__)

# Add OpenAPI specs for auth_server endpoints to the Swagger template
swagger_template = {
    "openapi": "3.0.2",
    "info": {
        "title": "IDRANJIA API",
        "version": API_VERSION,
        "description": "API documentation for IDRANJIA, including authentication endpoints.",
    },
    "paths": {
        # Only include endpoints data from other services here.
        # Do NOT include API server blueprint endpoints here since they are automatically generated.
        "/auth/login": {
            "post": {
                "tags": ["Authentication (auth_server)"],
                "summary": "Login endpoint to authenticate users and generate JWT tokens.",
                "requestBody": {
                    "required": True,
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "email": {
                                        "type": "string",
                                        "example": "user@example.com",
                                    },
                                    "password": {
                                        "type": "string",
                                        "example": "mypassword",
                                    },
                                },
                                "required": ["email", "password"],
                            }
                        }
                    },
                },
                "responses": {
                    "200": {
                        "description": "Successful login, returns JWT tokens",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "type": "object",
                                    "properties": {
                                        "access_token": {"type": "string"},
                                        "refresh_token": {"type": "string"},
                                    },
                                }
                            }
                        },
                    },
                    "400": {"description": "Bad request (missing or invalid data)"},
                    "401": {"description": "Invalid credentials"},
                },
            }
        },
        "/auth/validate": {
            "post": {
                "tags": ["Authentication (auth_server)"],
                "summary": "Validate endpoint to check the validity of a JWT token.",
                "security": [{"bearerAuth": []}],
                "responses": {
                    "200": {
                        "description": "Token is valid",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "type": "object",
                                    "properties": {
                                        "identity": {"type": "string"},
                                        "role": {"type": "string"},
                                    },
                                }
                            }
                        },
                    },
                    "401": {"description": "Invalid or expired token"},
                },
            }
        },
        "/auth/refresh": {
            "post": {
                "tags": ["Authentication (auth_server)"],
                "summary": "Refresh endpoint to issue a new access token using a refresh token.",
                "security": [{"bearerAuth": []}],
                "responses": {
                    "200": {
                        "description": "New access token issued",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "type": "object",
                                    "properties": {
                                        "access_token": {"type": "string"},
                                    },
                                }
                            }
                        },
                    },
                    "401": {"description": "Invalid or expired refresh token"},
                },
            }
        },
        "/health": {
            "get": {
                "tags": ["Authentication (auth_server)"],
                "summary": "Health check endpoint to verify the auth server is running.",
                "responses": {
                    "200": {
                        "description": "Server is healthy",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "type": "object",
                                    "properties": {
                                        "status": {"type": "string", "example": "ok"},
                                    },
                                }
                            }
                        },
                    }
                },
            }
        },
    },
    "components": {
        "securitySchemes": {
            "bearerAuth": {"type": "http", "scheme": "bearer", "bearerFormat": "JWT"}
        }
    },
}

# Configure Flasgger (Swagger UI) with the combined template
main_api.config["SWAGGER"] = {
    "title": "IDRANJIA API Documentation",
    "uiversion": 3,
    "openapi": "3.0.2",
}
# Initialize Swagger
swagger = Swagger(main_api, template=swagger_template, config=SWAGGER_CONFIG)

# Configure JWT validation settings
main_api.config["JWT_SECRET_KEY"] = (
    JWT_SECRET_KEY  # Same secret key as the auth microservice
)
main_api.config["JWT_ALGORITHM"] = (
    JWT_ALGORITHM  # Same algorithm as the auth microservice
)
main_api.config["JWT_TOKEN_LOCATION"] = JWT_TOKEN_LOCATION  # Where to look for tokens
main_api.config["JWT_QUERY_STRING_NAME"] = (
    JWT_QUERY_STRING_NAME  # Custom query string name
)
main_api.config["JWT_JSON_KEY"] = JWT_JSON_KEY  # Custom JSON key for access tokens
main_api.config["JWT_REFRESH_JSON_KEY"] = (
    JWT_REFRESH_JSON_KEY  # Custom JSON key for refresh tokens
)
main_api.config["JWT_REFRESH_TOKEN_EXPIRES"] = (
    JWT_REFRESH_TOKEN_EXPIRES  # Refresh token valid duration
)
main_api.config["SQLALCHEMY_DATABASE_URI"] = SQLALCHEMY_DATABASE_URI
main_api.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = SQLALCHEMY_TRACK_MODIFICATIONS

# Initialize JWTManager for validation only
jwt = JWTManager(main_api)

# Initialize Marshmallow
ma = Marshmallow(main_api)

# Initialize SQLAlchemy
db.init_app(main_api)

# Standardized error message constants for consistent JSON responses
ERROR_MESSAGES = {
    "bad_content_type": "Request body must be valid JSON with Content-Type: application/json",
    "empty_body": "Request body must not be empty",
    "invalid_json": "Invalid JSON format",
    "rate_limited": "Rate limit exceeded",
    "sql_injection_key": "Invalid JSON key: {key} suspected SQL injection",
    "sql_injection_value": "Invalid JSON value for key '{key}': suspected SQL injection",
    "sql_injection_path": "Invalid path variable: {key} suspected SQL injection",
    "payload_too_large": "Request body or field too large",
}


# Helper functions for pre-request checks
def is_input_safe(
    data: Union[str, List[Any], Dict[Any, Any], Tuple[Any]],
    _current_recursion_depth: int = 0,
    _max_recursion_depth: int = SQL_SCAN_MAX_RECURSION_DEPTH,
) -> bool:
    """
    Check if the input data contains SQL instructions.

    Improvements over previous implementation:
    - Treats common scalar types (None, int, float, bool) as safe.
    - Limits recursion depth to avoid excessive work on deeply nested payloads.
    - Limits per-string scan length to the configured `SQL_SCAN_MAX_LEN` to avoid ReDoS.
    - Does not raise TypeError for unknown scalars; instead coerces to str and scans.

    Returns True if safe, False if potentially unsafe.
    """
    # Protect against extremely deep recursion / malicious nesting
    if _current_recursion_depth > _max_recursion_depth:
        # treat overly deep structures as unsafe
        return False

    # None and scalar numeric/bool types are considered safe
    if data is None or isinstance(data, (int, float, bool)):
        return True

    # Strings: check up to SQL_SCAN_MAX_LEN characters to avoid expensive scanning
    if isinstance(data, str):
        try:
            to_scan = data if len(data) <= SQL_SCAN_MAX_LEN else data[:SQL_SCAN_MAX_LEN]
        except Exception:
            # If len() fails for some custom type masquerading as str, coerce and limit
            s = str(data)
            to_scan = s if len(s) <= SQL_SCAN_MAX_LEN else s[:SQL_SCAN_MAX_LEN]
        return not bool(SQL_PATTERN.search(to_scan))

    # Lists/tuples: check each element recursively, increasing depth
    if isinstance(data, (list, tuple)):
        # cheap safety: reject extremely large lists
        if len(data) > 10000:
            return False
        for item in data:
            if not is_input_safe(
                item,
                _current_recursion_depth=_current_recursion_depth + 1,
                _max_recursion_depth=_max_recursion_depth,
            ):
                return False
        return True

    # Dicts: check keys (if strings) and values recursively
    if isinstance(data, dict):
        # cheap safety: reject extremely large dicts
        if len(data) > 10000:
            return False
        for key, value in data.items():
            if isinstance(key, str):
                key_to_scan = (
                    key if len(key) <= SQL_SCAN_MAX_LEN else key[:SQL_SCAN_MAX_LEN]
                )
                if SQL_PATTERN.search(key_to_scan):
                    return False
            # Recurse for the value
            if not is_input_safe(
                value,
                _current_recursion_depth=_current_recursion_depth + 1,
                _max_recursion_depth=_max_recursion_depth,
            ):
                return False
        return True

    # For any other type, coerce to string and scan a limited slice
    try:
        s = str(data)
        to_scan = s if len(s) <= SQL_SCAN_MAX_LEN else s[:SQL_SCAN_MAX_LEN]
        return not bool(SQL_PATTERN.search(to_scan))
    except Exception:
        # If coercion fails, mark as unsafe
        return False


def _check_size_within_limit(
    data: Union[str, List[Any], Dict[Any, Any], Tuple[Any]], max_len: int = SQL_SCAN_MAX_LEN
) -> bool:
    """
    Recursively ensure that no string in the provided data exceeds the configured
    per-field limit. Returns True when within limits, False otherwise.
    """

    # check string length
    if isinstance(data, str):
        return len(data) <= max_len
    
    # check lists/tuples recursively
    if isinstance(data, (list, tuple)):
        for item in data:
            if not _check_size_within_limit(item, max_len=max_len):
                return False
        return True
    
    # check dicts recursively
    if isinstance(data, dict):
        for key, value in data.items():
            # keys can be non-strings; only check string keys
            if isinstance(key, str) and len(key) > max_len:
                return False
            if not _check_size_within_limit(value, max_len=max_len):
                return False
        return True
    
    # other types are not size-checked
    return True


def _validate_user_data() -> Optional[Tuple[Any, int]]:
    """
    Helper: validate user data for incoming requests by checking for SQL injection.

    Invoked by `pre_request_checks` handler so the execution order is explicit.

    Returns:
        Optional[Tuple[Any, int]]: Flask response tuple (body, status) when
        validation fails, otherwise None.
    """

    # Validate JSON body for POST, PUT, PATCH methods
    if request.method in ["POST", "PUT", "PATCH"]:
        # Quickly reject requests that declare an excessive Content-Length
        if (
            request.content_length is not None
            and request.content_length > API_SERVER_MAX_JSON_SIZE
        ):
            return (
                jsonify({"error": ERROR_MESSAGES["payload_too_large"]}),
                STATUS_CODES.get("payload_too_large", 413),
            )

        # Ensure Content-Type is application/json and body is valid JSON
        if not request.is_json or request.json is None:
            return (
                jsonify({"error": ERROR_MESSAGES["bad_content_type"]}),
                STATUS_CODES["bad_request"],
            )
        
        # Parse JSON body
        try:
            data = request.get_json(silent=False) # silent=False to raise on invalid JSON
            if data == {}:
                return (
                    jsonify({"error": ERROR_MESSAGES["empty_body"]}),
                    STATUS_CODES["bad_request"],
                )
        except ValueError:
            return (
                jsonify({"error": ERROR_MESSAGES["invalid_json"]}),
                STATUS_CODES["bad_request"],
            )

        # Ensure no individual string field is excessively large (recursive check)
        if not _check_size_within_limit(data):
            return (
                jsonify({"error": ERROR_MESSAGES["payload_too_large"]}),
                STATUS_CODES.get("payload_too_large", 413),
            )

        # Validate JSON keys and values for SQL injection
        for key, value in data.items():
            if not is_input_safe(key):
                return (
                    jsonify(
                        {"error": ERROR_MESSAGES["sql_injection_key"].format(key=key)}
                    ),
                    STATUS_CODES["bad_request"],
                )
            if isinstance(value, str) and not is_input_safe(value):
                return (
                    jsonify(
                        {"error": ERROR_MESSAGES["sql_injection_value"].format(key=key)}
                    ),
                    STATUS_CODES["bad_request"],
                )

    # Validate path variables (if needed)
    if request.view_args:  # Check if view_args is not None
        for key, value in request.view_args.items():
            if not is_input_safe(value):
                return (
                    jsonify(
                        {"error": ERROR_MESSAGES["sql_injection_path"].format(key=key)}
                    ),
                    STATUS_CODES["bad_request"],
                )


def _enforce_rate_limit() -> Optional[Tuple[Any, int]]:
    """
    Helper: enforce rate limiting for incoming requests.
    Uses `is_rate_limited` function imported from `api_blueprints.blueprints_utils`, TTLCache-based.
    Rate limit related data is tracked per-client IP and shared between all blueprints and this main API server.

    Invoked in a controlled order by `pre_request_checks` function.
    """

    # Check if rate limiting is enabled
    if API_SERVER_RATE_LIMIT:
        client_ip = request.remote_addr # Get client IP address
        if is_rate_limited(client_ip): # Check if the client IP has exceeded the rate limit
            return (
                jsonify({"error": ERROR_MESSAGES["rate_limited"]}),
                STATUS_CODES["too_many_requests"],
            )


@main_api.before_request
def pre_request_checks() -> Optional[Tuple[Any, int]]:
    """
    Combined before-request handler that runs all request-level validators in
    a clearly documented order.

    Behavior and order:
    - Validation (_validate_user_data) runs first. If it returns a response
      (indicating invalid input), that response is immediately returned to the
      client.
    - Rate limiting (_enforce_rate_limit) runs second. If it returns a
      response (rate limit exceeded), that response is returned.

    Note: Flask will call all registered `before_request` handlers in the
    order they were registered. By centralizing into `pre_request_checks`, the
    order becomes explicit and easier to reason about.
    """

    # Run validation first
    resp = _validate_user_data()
    if resp is not None:
        return resp

    # Then apply rate limiting
    resp = _enforce_rate_limit()
    if resp is not None:
        return resp


def _sanitize_callback(callback: object, max_len: int = 200, fp_len: int = 12):
    """Normalize and redact untrusted callback text for safe logging.

    Returns a tuple (short_snippet, fingerprint) where short_snippet is a
    truncated, control-character-free, token-redacted string safe for logs,
    and fingerprint is a short HMAC-SHA256/sha256 hex prefix for correlation.
    """

    # Ensure string form
    raw = "" if callback is None else str(callback)

    # Normalize unicode to a stable form
    raw = unicodedata.normalize("NFKC", raw)

    # Collapse newlines/tabs into space and remove control characters
    raw = re.sub(r"[\r\n\t]+", " ", raw)
    raw = "".join(ch if unicodedata.category(ch)[0] != "C" else "?" for ch in raw)

    # Redact obvious JWTs (three base64url parts) and long base64-like tokens
    raw = re.sub(
        r"[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+\.[A-Za-z0-9_\-]+", "<REDACTED_JWT>", raw
    )
    raw = re.sub(r"[A-Za-z0-9_\-]{20,}", "<REDACTED_TOKEN>", raw)

    # Truncate to a safe length for logs
    short = (raw[:max_len] + "...") if len(raw) > max_len else raw

    # Compute fingerprint using HMAC with server secret if available, fallback to sha256
    try:
        key = (
            JWT_SECRET_KEY if "JWT_SECRET_KEY" in globals() and JWT_SECRET_KEY else None
        )
        if key:
            fp = hmac.new(
                str(key).encode("utf-8"), str(callback).encode("utf-8"), hashlib.sha256
            ).hexdigest()[:fp_len]
        else:
            fp = hashlib.sha256(str(callback).encode("utf-8")).hexdigest()[:fp_len]
    except Exception:
        fp = hashlib.sha256(short.encode("utf-8")).hexdigest()[:fp_len]

    return short, fp


# Handle unauthorized access (missing token)
@jwt.unauthorized_loader
def custom_unauthorized_response(callback):
    # sanitize and fingerprint the callback before logging
    cb_short, cb_fp = _sanitize_callback(callback) # get sanitized callback and fingerprint
    log(
        log_type="error",
        message=f"api reached with missing token, callback: {cb_short} [fp:{cb_fp}]",
        structured_data=f"[host: {API_SERVER_HOST}, port: {API_SERVER_PORT}]",
    )
    return (
        jsonify(INVALID_JWT_MESSAGES["missing_token"][0]),
        INVALID_JWT_MESSAGES["missing_token"][1],
    )


# Handle invalid tokens
@jwt.invalid_token_loader
def custom_invalid_token_response(callback):
    # sanitize and fingerprint the callback before logging
    cb_short, cb_fp = _sanitize_callback(callback) # get sanitized callback and fingerprint
    log(
        log_type="error",
        message=f"api reached with invalid token, callback: {cb_short} [fp:{cb_fp}]",
        structured_data=f"[host: {API_SERVER_HOST}, port: {API_SERVER_PORT}]",
    )
    return (
        jsonify(INVALID_JWT_MESSAGES["invalid_token"][0]),
        INVALID_JWT_MESSAGES["invalid_token"][1],
    )


# Helper function to summarize JWT headers and payloads in logs
def _summarize(d: dict, keys: tuple):

    # if not a dict, return string representation
    if not isinstance(d, dict):
        return str(d)
    
    # extract specified keys with truncation
    out = {}
    for k in keys:
        if k in d:
            v = d[k]
            if isinstance(v, str) and len(v) > 64:
                v = v[:64] + "..."  # truncate long values
            out[k] = v

    # fallback: show first 5 keys if none of the specified keys found
    return out or {"keys": list(d.keys())[:5]}


# Handle expired tokens
@jwt.expired_token_loader
def custom_expired_token_response(jwt_header, jwt_payload):

    # summarize header and payload for logging
    header_summary = _summarize(jwt_header, ("alg", "typ", "kid", "jti"))
    payload_summary = _summarize(
        jwt_payload, ("sub", "identity", "jti", "exp", "role", "iss", "aud")
    )

    log(
        log_type="error",
        message=(
            "API reached with expired JWT. "
            f"Header summary: {header_summary}; Payload summary: {payload_summary}"
        ),
        structured_data=f"[host: {API_SERVER_HOST}, port: {API_SERVER_PORT}]",
    )

    return (
        jsonify(INVALID_JWT_MESSAGES["expired_token"][0]),
        INVALID_JWT_MESSAGES["expired_token"][1],
    )


# Handle revoked tokens (if applicable)
@jwt.revoked_token_loader
def custom_revoked_token_response(jwt_header, jwt_payload):

    # summarize header and payload for logging
    header_summary = _summarize(jwt_header, ("alg", "typ", "kid", "jti"))
    payload_summary = _summarize(
        jwt_payload, ("sub", "identity", "jti", "exp", "role", "iss", "aud")
    )

    log(
        log_type="error",
        message=(
            "API reached with revoked JWT. "
            f"Header summary: {header_summary}; Payload summary: {payload_summary}"
        ),
        structured_data=f"[host: {API_SERVER_HOST}, port: {API_SERVER_PORT}]",
    )

    return (
        jsonify(INVALID_JWT_MESSAGES["revoked_token"][0]),
        INVALID_JWT_MESSAGES["revoked_token"][1],
    )


@main_api.route(f"/api/{API_VERSION}/health", methods=["GET"])
def health_check():
    """
    ---
    tags:
      - API Server (api_server)
    summary: Health Check
    description: Returns the status of the API server.
    operationId: api_health_check
    responses:
      200:
        description: Server is running and healthy.
        content:
          application/json:
            schema:
              type: object
              properties:
                status:
                  type: string
                  example: ok
    """

    return jsonify({"status": "ok"}), STATUS_CODES["ok"]


if __name__ == "__main__":

    # Register the blueprints
    blueprints_dir: str = os_path_join(
        os_path_dirname(os_path_abspath(__file__)), "api_blueprints"
    )

    # Ensure the api_blueprints directory exists and contains at least one Python file
    try:
        entries = os_listdir(blueprints_dir)
    except Exception as ex:
        # Log the error and exit if the directory is missing or inaccessible
        log(
            log_type="error",
            message=f"Blueprints directory '{blueprints_dir}' not found or inaccessible: {ex}",
            structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
        )
        # Also print to console for immediate feedback
        print(f"ERROR: api_blueprints directory not found or inaccessible: {ex}")
        sys.exit(1) # exit with error

    # Require at least one .py file to proceed (avoid starting with an empty blueprints dir)
    python_files = [f for f in entries if f.endswith(".py")]
    if not python_files:
        # if no Python files found, log and exit
        log(
            log_type="error",
            message=f"No Python files found in '{blueprints_dir}'. At least one file is required.",
            structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
        )
        print(
            f"ERROR: No Python files found in {blueprints_dir}; add at least one blueprint file."
        ) # Print to console for immediate feedback
        sys.exit(1) #exit with error

    for filename in os_listdir(blueprints_dir):
        # Only consider Python files following the *_bp.py naming convention
        # (i.e. files meant to define blueprints)
        if not filename.endswith("_bp.py"):
            continue

        module_name: str = filename[:-3] # strip .py extension
        full_module_name = f"api_blueprints.{module_name}" # construct full import path

        # Try importing the module; log and continue on failure
        try:
            module = import_module(full_module_name)
        except Exception as ex:
            log(
                log_type="error",
                message=(
                    f"Failed to import blueprint module '{full_module_name}': {ex}"
                ),
                structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
            )
            print(f"Skipping {full_module_name}: import failed: {ex}")
            continue

        # Discover all flask.Blueprint instances in api_blueprints.<module>
        found_blueprints = []
        for attr_name in dir(module):
            # skip private attributes quickly
            if attr_name.startswith("_"):
                continue
            try:
                attr = getattr(module, attr_name)
            except Exception:
                # If accessing an attribute raises, skip it (but don't crash startup)
                continue

            # Only accept actual Flask Blueprint instances
            if isinstance(attr, Blueprint):
                found_blueprints.append((attr_name, attr))

        if not found_blueprints:
            # If the module doesn't export a Blueprint, log a warning and continue
            log(
                log_type="warning",
                message=(f"No Flask Blueprint found in module '{full_module_name}'."),
                structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
            )
            print(f"No blueprint found in {full_module_name}; skipping.")
            continue

        # Register all discovered Blueprints
        for attr_name, blueprint in found_blueprints:
            try:
                main_api.register_blueprint(blueprint, url_prefix=URL_PREFIX) # Register with proper URL prefix
                # Log successful registration
                print(
                    f"Registered blueprint: {full_module_name}.{attr_name} with prefix {URL_PREFIX}"
                )
            except Exception as ex: 
                log(
                    log_type="error",
                    message=(
                        f"Failed to register blueprint '{full_module_name}.{attr_name}': {ex}"
                    ),
                    structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
                ) # Log the error
                print(f"Failed to register {full_module_name}.{attr_name}: {ex}") # Print to console for immediate feedback

    # Initialize the database inside the app context
    with main_api.app_context():
        try:
            db.create_all()
        except OperationalError as e:
            # Log a clear, structured message and exit cleanly so startup doesn't crash with an opaque traceback
            log(
                log_type="error",
                message=f"Database connection failed during create_all: {e}",
                structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
            )
            print(
                "ERROR: cannot connect to the database. Check Postgres is running and SQLALCHEMY_DATABASE_URI in config."
            ) # Print to console for immediate feedback
            sys.exit(1) # exit with error

    # Log the server start
    log(
        log_type="info",
        message="API server started",
        structured_data=f"[host='{API_SERVER_HOST}' port='{API_SERVER_PORT}']",
    )

    # Start the server
    main_api.run(
        host=API_SERVER_HOST,
        port=API_SERVER_PORT,
        debug=API_SERVER_DEBUG_MODE,
        ssl_context=(
            (API_SERVER_SSL_CERT, API_SERVER_SSL_KEY) if API_SERVER_SSL else None
        ),
    )
